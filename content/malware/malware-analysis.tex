\section{Malware Analysis}\label{section:malware analysis}
Malware analysis is the research field that focuses on extracting information from malware (and the infrastructure supporting malware). As most malware is created as a Windows executable binary, malware analysis has a heavy focus on the analysis of Windows executables.

\medskip

The goals of the analysis of a malware sample range from purely technical (e.g. what is the sample capable of doing?) to looking at an actor and their goals as a whole (e.g. why is an actor trying to infect specific targets?).

\medskip

There are two types of malware analysis \cite{practical-malware-analysis}:
\begin{itemize}
    \item \emph{Static} malware analysis: Useful information is extracted from a malware sample to get an idea of how it works. For example, a simple, useful technique is to extract strings from a malware binary as these give clues about its inner workings (e.g. URLs that the malware contacts). An important part of static analysis is translating the machine code in the binary to human-readable assembly code (i.e. disassembling) to see what a malware sample does on a low-level, without running it.

    \item \emph{Dynamic} malware analysis: A sample of malware is executed in a sandbox (i.e. a controlled environment) and its actions are monitored. Modern malware often employs techniques to detect whether it is running in a sandbox to evade dynamic analysis.
\end{itemize}

In this thesis, we focus on static analysis.

\subsection{The Advantages \& Limitations of Static Analysis}
Both static and dynamic malware analysis have their advantages and limitations \cite{survey-anti-analysis}. As static analysis does not run the samples that are being analyzed, it is relatively safe and scalable, as you do not have to set up and clean a testing environment for each sample you test.

The biggest drawback of static malware analysis is that it requires disassembling and understanding the binary code inside an executable. This is a complex and hard problem to solve, as it is often only clear what a program does when it is run\footnote{The Halting Problem shows us that creating a general algorithm to determine the functionality of a program without running the program is undecidable \cite{halting-problem}. This, of course, also holds for malware \cite{impossible-virus-detection}.}. Malware authors obfuscate their malware to make it even harder to parse (e.g. by interleaving code and data throughout a binary).

\subsection{IDA Pro}\label{section:ida pro}
Disassemblers are programs that take a binary and parse the binary code into human-readable assembly code. They often also perform code analysis on the assembly. For example, to detect cross-references and Windows API imports.

The best-known reverse engineering toolkit is IDA Pro by Hex-Rays\footnote{\tiny \url{https://www.hex-rays.com/ida-pro/}} \cite{ida_guide}. Other popular options include Ghidra\footnote{\tiny \url{https://ghidra-sre.org/}} and Radare2\footnote{\tiny \url{https://rada.re/n/}}.

\medskip

IDA Pro is a reverse engineering toolkit with many advanced features:
\begin{itemize}
    \item Standard static analysis tools such as a disassembler, detection of strings and detection of imports in the import table (discussed in \autoref{section:background calling api functions}).

    \item Graph view: IDA Pro allows you to visualize the basic blocks in a function as a graph. For example, see \autoref{fig:control flow graph}.

    \item Support for many types of binaries, operating systems, and instructions sets.

    \item Decompiler: One of the most important parts of IDA Pro is the state-of-the-art decompiler that can be used to decompile a binary into C-like pseudocode.

    \item Debugging: Support for multiple debuggers to closely observe what an application does, while it is running. As this runs the executable, it is used for dynamic analysis of binaries.
\end{itemize}

\subsubsection{Plugins}\label{section:ida pro plugins}
IDA Pro provides an API that can be used to develop plugins\footnote{\tiny \url{https://www.hex-rays.com/products/ida/tech/plugin/}}. Plugins are able to extend and use virtually every feature in IDA Pro, making them a powerful tool to automate part of malware analyses. Plugins are written in either IDC \footnote{\tiny \url{https://www.hex-rays.com/products/ida/support/idadoc/157.shtml}} (a variant of C specifically made for IDA Pro) or Python\footnote{\tiny \url{https://github.com/idapython/src}}.

 A drawback of developing IDA Pro plugins is the limited documentation of the API\footnote{\tiny \url{https://www.hex-rays.com/products/ida/support/idapython_docs/}}. Because of this, a common practice in IDA Pro plugin development is looking for existing, open source plugins and see how they work, instead of reading the API documentation.

In \autoref{chapter:plugin}, we implement the ideas of \autoref{chapter:call signatures} in an IDA Pro plugin.
